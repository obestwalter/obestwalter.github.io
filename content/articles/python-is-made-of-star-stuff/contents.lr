title: Python is made of star-stuff
---
crtime: 2019-11-02
---
mtime: 2019-11-02
---
tags:

python
fundamentals
little-things
---
summary:

[![hubble telescope picture of messier9 star cluster](hubble-messier9.jpg)](https://www.nasa.gov/mission_pages/hubble/science/messier9.html)

Carl Sagan wrote in Cosmos that we are all made of "star-stuff". I think this is important to become aware of now and then. All of the elements that make life on earth possible were formed in a star at some point. It puts things into perspective if we can remember that life is a miracle in the sense that we fundamentally have no clue **how** all this is possible and **why** we run around on this rock hurtling through space. You ask yourself what this has to do with Python? Right - nothing, but obvioulsy the humans involved in the development of Python are also made of star-stuff and I like to believe that their deep sense of wonder about the miracle of life has inspired them to put so darn many stars into its syntax. 

---
content:

The innocent little **&#10033;** (star or asterisk) is a very versatile syntax element and operator in most programming languages. Let's look at its uses in Python:


```python
# Yes. This code makes no sense. Thanks for pointing it out.

from os import *

def sparkle_appender(*, end=linesep):
    def _sparkle_appender(function):
        def star_reporter(*args, **kwargs):
            print(*args, **kwargs, end=end)
            return function(*args, **kwargs)
        return star_reporter
    return _sparkle_appender

@sparkle_appender(end=" ❇❇❇" + linesep)
def wrapped(stars, bars):
    first, *middle, last = stars
    for elem in [*middle, last, *bars]:
        first *= 2 ** elem
    return first
```
## Simple things first: &#10033; and &#10033;&#10033; operators

One of the first things a new Python disciple might learn is how to use Python as a calculator - like in many other languages &#10033; is the multiplication operator and &#10033;&#10033; is used for exponentiation - e.g.:


```python
2 * 2
```
```text
[result]
4```

```python
2 ** 4
```
```text
[result]
16```

```python
'spam' * 3

```
```text
[result]
'spamspamspam'```
Although it makes no sense, the star-spangled code example further up actually works. If you look at the `wrapped` function, &#10033; is used as a boring old mathematical operator: `first *= 2 ** elem` (which is the same as `first = first * 2 ** elem`).


```python
result = wrapped([1, 2, 3, 4], (23, 42))
print("result of calculation:", result)
```
```text
[stdout]
[1, 2, 3, 4] (23, 42) ❇❇❇
result of calculation: 18889465931478580854784
```
## Enforcing the API of a function

If your function needs 23 arguments you have a big problem anyway but you can at least alleviate it a bit by making calls to that function more readable. Passing some or all arguments as keyword arguments usually helps. Problem is: the caller normally has the choice how to pass the arguments. You can even call a "keyword only" function like this:


```python
def kw_only_you_wish(spam=None, eggs=None, lobster=None):
    return spam + eggs * lobster

kw_only_you_wish(2, 3 ,4)
```
```text
[result]
14```
With [Python3.0](https://docs.python.org/3.0/whatsnew/3.0.html#new-syntax) a new syntax was introduced to make enforcement of so called "keyword-only arguments" possible. This is used in the definition of the `sparkle_appender` function above. When using this, everything after the `[, ]*,` **has** to be passed as keyword argument or you get into trouble:


```python
@sparkle_appender(" ❈❈❈ ")
def badly_wrapped():
    pass
```
```text
[TypeError]
sparkle_appender() takes 0 positional arguments but 1 was given```
### Pack and unpack arguments

This goes back at least until Python2.7 and in this case &#10033; and &#10033;&#10033; are syntax elements to be used as prefix, when [defining or calling functions](https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments). The idea is usually that you want to pass through parameters to an underlying function without having to care about what or even how many they are. In this example we have a function that is just passing through arguments without needing to now anything about them:


```python
def passing_things_through_function(*args, **kwargs):
    print(f"passing through {args=} and {kwargs=}")
    the_actual_function(*args, **kwargs)

def the_actual_function(a, b, c=None, d=None):
    print(f"passed arguments: {a=}, {b=}, {c=}, {d=}")
    
passing_things_through_function(*[1, 2], **dict(c=3, d=4))
```
```text
[stdout]
passing through args=(1, 2) and kwargs={'c': 3, 'd': 4}
passed arguments: a=1, b=2, c=3, d=4
```
A case where this is particularly useful is when creating decorators that are pretty generic in what they do (like the `sparkle_appender`). They just need to pass through whatever the decorated function needs to be called with.

### There is even more to unpack

In pre Python3 days Python already supported so-called tuple unpacking which made things like this possible:


```python
# swap the values of a and b
a = 1
b = 2
a, b = b, a
print(f"{a=}, {b=}")
```
```text
[stdout]
a=2, b=1
```
[PEP 3132 - extended iterable unpacking](https://www.python.org/dev/peps/pep-3132/) brought the star into the "classic" tuple unpacking (which was never restricted to tuples but that name somehow stuck):



```python
for iterable in [
    "egg", 
    [1, 2, 3], 
    (1, 2, 3), 
    {1, 2, 3}, 
    {1: 'a', 2: 'b', 3: 'c'}
]:
    print(f"{iterable} ({type(iterable)}):")
    a, b, c = iterable
    print(f"a, b, c        -> {a} {b} {c}")
    *a, b = iterable
    print(f"*a, b = iterable -> {a} {b}")
    a, *b = iterable
    print(f"a, *b = iterable -> {a} {b}\n")
```
```text
[stdout]
egg (<class 'str'>):
a, b, c        -> e g g
*a, b = iterable -> ['e', 'g'] g
a, *b = iterable -> e ['g', 'g']

[1, 2, 3] (<class 'list'>):
a, b, c        -> 1 2 3
*a, b = iterable -> [1, 2] 3
a, *b = iterable -> 1 [2, 3]

(1, 2, 3) (<class 'tuple'>):
a, b, c        -> 1 2 3
*a, b = iterable -> [1, 2] 3
a, *b = iterable -> 1 [2, 3]

{1, 2, 3} (<class 'set'>):
a, b, c        -> 1 2 3
*a, b = iterable -> [1, 2] 3
a, *b = iterable -> 1 [2, 3]

{1: 'a', 2: 'b', 3: 'c'} (<class 'dict'>):
a, b, c        -> 1 2 3
*a, b = iterable -> [1, 2] 3
a, *b = iterable -> 1 [2, 3]

```
### ... and in the other direction

Pretty much analogous to how &#10033; and &#10033;&#10033; are used in function calls they can be used in literals to create new iterables or mappings:

This syntax to merge iterables was implemented via [PEP 448 (additional unpacking generalizations)](https://www.python.org/dev/peps/pep-0448/) in Python3.5[^1]. 

[^1]: For the historically interested: discussion on the mailing list [part I](https://mail.python.org/pipermail/python-dev/2015-February/138078.html) and [part II](https://mail.python.org/pipermail/python-dev/2015-February/138564.html). 


```python
a, b = [1, 2, 3], [4, 5, 6]
[*a, *b]
```
```text
[result]
[1, 2, 3, 4, 5, 6]```

```python
a, b = {1: 2, 2: 3, 3: 4}, {1: 4, 4: 5, 5: 6}
{**a, **b}
```
```text
[result]
{1: 4, 2: 3, 3: 4, 4: 5, 5: 6}```

```python
a, b = {1, 2 ,3}, {3, 4 ,5}
{*a, *b}  
```
```text
[result]
{1, 2, 3, 4, 5}```
This is the more "natural" approach for sets though (union):


```python
a | b  
```
```text
[result]
{1, 2, 3, 4, 5}```
As the underlying functionality only cares about whether something is iterable, you can mix and match. This creates a tuple from a list and a set:


```python
(*[1, 2 ,3], *{3, 4 ,5})
```
```text
[result]
(1, 2, 3, 3, 4, 5)```
Be aware though that merging is flat - no nesting. Later keys overwrite earlier ones. Here `foo` will contain the second dict after merging:


```python
a = {"a": 1, "foo": { "a": 1}}
b = {"a": 1, "foo": { "b": 2, "c": 3}}
{**a, **b}
```
```text
[result]
{'a': 1, 'foo': {'b': 2, 'c': 3}}```
## Import all the things

The last star shines a bit dimly as this is usually an [antipattern](http://wiki.c2.com/?AntiPattern) and it looks like this:


```python
from os import *
```
this is usually not a good idea because:

* static code analysis tools can't warn you about unresolved references
* it causes namespace pollution which might badly break your code (e.g. if a module you import all the names from redefines `open` or some other inbuilt)
* you can't see easily from where a name was imported (like in the example above - where does `linesep` come from?)

If a package (or module[^2]) is explicitly designed to be imported like this, this is usually documented and the authors defined the special module attribute   [`__all__`](https://docs.python.org/3/tutorial/modules.html?highlight=__all__#importing-from-a-package) that explicitly lists the names that should be imported when using `from <module or package> import *` 

[^2]: I'm either not seeing it or the Python documentation is omitting that `__all__` also works for modules. It does though ... I tried it.

!!! This article is generated from a [Jupyter notebook](https://jupyter.org/) running in a Python3.8 kernel. You can [download it](https://oliver.bestwalter.de/articles/python-is-made-of-star-stuff/python-is-made-of-star-stuff.ipynb) and play with it.

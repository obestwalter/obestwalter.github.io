title: Obligatory meta article about my website
---
mtime: 2019-11-03
---
crtime: 2019-11-03
---
tags:

meta
python
lektor
jupyter
diy
---
summary:

![a normal day in the office (keeping the lab equipment from exploding)](normal-day-at-the-office.gif)

When I was hyping myself up to write the second article on my website after almost 3 years I naturally had a look how I can busy myself with everything else but writing the actual article (while still fooling myself into believing this is a necessary preparation for ... **just writing the darn article**. But I think the work in my website generation laboratory was worth the fuzz this time, as I quite enjoy the new workflow. I enjoy it so much, that I am actually publishing articles now. I now can write code sprinkled articles in a Jupyter notebook and have them rendered automatically into my lektor generated website using a bit of Python code hooked into lektors plugin system.

---
content:

It is a never ending story: every time I want to write an article to publish on my website, I change my blog engine instead. At some point I even created my own [static website generator](https://github.com/obestwalter/loslassa). All this fuzz just to avoid actually writing things to ... you know ... put on a website :). This might be excused by the fact that I really enjoy spending my leisure time tinkering with things aimlessly rather then actually producing something that might be useful, but I finally started seeing through my evil self-sabotage mechanisms and was determined to put a stop to it! So I did the natural thing: I went to my lab[^1] and tinkered with the engine.

[^1]: Can anyone tell me from which film this gif is? I found it on [tenor](https://tenor.com/view/scientist-mad-scientist-experiment-lab-laboratory-gif-11957205) and would like to give proper credit

## Ingredients

### 1) A static website generator generator (sic!)

I played with a lot of blog engines over the years - while never really blogging anything. I mostly work in backend development, but there is something that fascinates me about web design and web development. It's one of these things I guess :). 

I am particularly fond of static website generators that provide a workflow that is similar to developing software. I played with [pelican](https://blog.getpelican.com/), [jekyll](https://jekyllrb.com/), [hugo](https://gohugo.io/), [nikola](https://getnikola.com/), [flask](https://flask.palletsprojects.com/) + [frozen-flask](https://github.com/Frozen-Flask/Frozen-Flask) and the lot. As already mentioned: I even wrote my own [sphinx](https://www.sphinx-doc.org/) based generator ... while still never really blogging anything. 

At the beginning of 2017 I made a deal with a colleague that I would finally write a blog article about the pytest development sprint and a bit about my involvement. It would have been boring though if I would have used the site I had already online (last incarnation was a simple [mkdocs](https://www.mkdocs.org/) driven [thing](https://github.com/obestwalter/obestwalter.github.io/blob/1.0.0/docs/index.md)). It would also have been boring to at least use one of the engines I already knew. Using something utterly profane like medium or wordpress was obviously completely out of the question! I mean, I could have just written the article then and be done with it. Who wants that? Right. Not me. So I started looking around for the next thing that could keep me from writing that article and I stumbled over [lektor](https://www.getlektor.com/). Now this was something that could keep me busy for a while as it is not simply a static website generator, but rather something that you can use to build a static website generator with - **a website generator generator**! Long story short: I set that up from scratch with a [simple sass style](https://github.com/obestwalter/obestwalter.github.io/blob/lektor-sources/_style/style.sass), wrote a [little plugin](https://github.com/obestwalter/obestwalter.github.io/blob/lektor-sources/packages/lektor-sass/lektor_sass.py) to integrate that into lektors development server, and finally actually wrote and [published that article](/articles/becoming-an-open-source-gardener/). Nobody ever made a deal with me again that forced me to write another article, so that was it. I had unlocked the *"i-have-a-blog-but-i-never-blog-achievement"* once again - only on a higher level. Until very recently.

Because very recently I realized that I had produced a lot of material while trying to teach Python and test automation to all kinds of folks over the last years. I finally wanted to start sharing some of these materials on my website. As making strange deals seems to work with my contorted psyche, I made a deal with myself to publish at least one article a month for at least a year.

This time I successfully resisted the temptation to start from scratch again and simply updated lektor and adjusted the existing setup to fit my new needs. The new needs arose from the fact that I work mostly in Jupyter Notebooks nowadays, when creating learning materials and I like it, so I want to write articles like that and have them integrate into my website. 

So the first ingredient stayed the same and is still lektor.
 
## 2) Jupyter notebooks

!!!! I was really determined this time to just make this work as quick and dirty as possible, so that I can do some actual writing. So this might be all horribly wrong, but it works well enough. As I am the only user I don't mind if things are a bit quirky as long as I understand what's going on.

Lektor generates the website from markdown by default. It has a plugin system that could theoretically be used to generate them from something else entirely and that is the usual approach that I have seen in other Jupyter integrations. Here is a very sophisticated approach to get it working with Nikola for example: [Binder + Nikola + Jupyter + Github = Blogging resourceless](http://damianavila.github.io/blog/posts/binder-%2B-nikola-%2B-jupyter-%2B-github-blogging-resourceless.html). There is also an (abandoned?) plugin for lektor to [integrate Jupyter](https://github.com/baldwint/lektor-jupyter). 

Generating HTML from a notebook comes out of the box via `nbconvert`. But doing it that way, would mean that I have to teach [`nbconvert`](https://nbconvert.readthedocs.io/) to generate HTML that is compatible with the HTML that is created from the lektor-style markdown and re-implement all the extra functionality that comes for free when generating it through lektor. So, instead I chose to generate markdown from the Jupyter notebook. From lektors point of view nothing changes and I am able to keep everything the same on that level. I can also still write articles directly in lektors markdown without going through a notebook, if I choose to. So all I need is adding a pre-processing step that generates markdown from the notebook.

Generating markdown from a notebook comes also out of the box via `nbconvert` - so if you take a notebook that looks like this in the browser:

[![example jupyter notebook](example-notebook.png)](https://github.com/obestwalter/obestwalter.github.io/blob/lektor-sources/content/articles/website-meta/example-notebook.ipynb)

... and convert it with `jupyter-nbconvert --to markdown example-notebook.ipynb`, out drops an `example-notebook-markdown.md` that contains this:

[![example markdown output](example-output.png)](https://github.com/obestwalter/obestwalter.github.io/blob/lektor-sources/content/articles/website-meta/example-notebook.md)

This is somehow already what I want, but I want the output to be marked properly and I don't want the whole traceback - just the name and message of the error is enough. So there is a little bit of massaging to be done. The question is: when should that happen? I could try to convert the generated output to my liking, but I'd rather poke a finger into my eye, so this has to happen, when I can still work with the data.

Thanks to the friendly Jupyter Development Team, `nbconvert` is written in a way that it is not too hard to make this possible by inheriting from [`ExecutePreprocessor`](https://nbconvert.readthedocs.io/en/latest/api/preprocessors.html#nbconvert.preprocessors.ExecutePreprocessor). This gives me the possibility to hook into the execution of individual code cells and massage the contents there. So this is what I came up with:


```python
# %load -s ArticleExecutePreprocessor ../../../lebut/ipynb_to_md.py
class ArticleExecutePreprocessor(ExecutePreprocessor):
    """Massage the code cell outputs to suit the blog.

    I'm sure there are more elegant ways, but this works for me atm.
    """

    def preprocess(self, nb, resources=None, km=None):
        srcUrl = f"{URL.WEBSITE_ARTICLES}/{resources['fileRelPath']}"
        version = f"{sys.version_info.major}.{sys.version_info.minor}"
        source = (
            f"!!! This article is generated from a "
            f"[Jupyter notebook](https://jupyter.org/) "
            f"running in a Python {version} kernel. "
            f"You can [download it]({srcUrl}) and play with it."
        )
        cell = nbformat.NotebookNode(
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": source,
            }
        )
        nb.cells.append(cell)
        super().preprocess(nb, resources=resources, km=km)

    def preprocess_cell(
            self, cell, resources, cell_index, store_history=True
    ):
        if cell.cell_type != "code":
            return cell, resources

        assert isinstance(cell.source, str)
        load_candidate = cell.source.replace("# ", "")
        if load_candidate.startswith("%load"):
            cell.source = self.apply_load_magic(load_candidate)
            return cell, resources

        _, outs = self.run_cell(cell, cell_index, store_history)
        new = [f"\n\n```python\n{cell.source}\n```"]
        for o in outs:
            if o.output_type == "execute_result":
                # TODO deal with other types as they come up
                data = o.data["text/plain"]
                new.append(f"```text\n[result]\n{data}```")
            elif o.output_type == "error":
                new.append(f"```text\n[{o.ename}]\n{o.evalue}```")
            elif o.output_type == "stream":
                new.append(f"```text\n[{o.name}]\n{o.text}```")
            else:
                raise Exception(f"dunno what to do with: {o}")
        cell = nbformat.NotebookNode(
            {
                "cell_type": "raw",
                "metadata": {},
                "source": "\n".join(new)
            }
        )
        return cell, resources

    def apply_load_magic(self, content):
        """Apply the %load magic manually.

        Cell magic is not automaticall applied by
        the preprocessor, so I do this directly here.

        I'm sure this is horribly wrong, but it works well enough.
        """
        magic = CodeMagics(shell=IPYTHON_SHELL)
        arg_s = " ".join(content.split()[1:])
        magic.load(arg_s)
        code = IPYTHON_SHELL.rl_next_input
        return code

```

If I run this through nbconvert now, the generated markdown looks like this:

[![example markdown improved](example-output-improved.png)]()

## 3) A lektor plugin to generate articles from a Jupyter notebook

XXX

## 4) A simple tox based development and publishing workflow

!!! This article is generated from a [Jupyter notebook](https://jupyter.org/) running in a Python 3.8 kernel. You can [download it](https://oliver.bestwalter.de/articles/website-meta/website-meta.ipynb) and play with it.
